/**
 * Generated by orval v7.0.1 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
import type {
  BearerResponse,
  BodyAuthJwtLoginAuthJwtLoginPost,
  BodyResetForgotPasswordAuthForgotPasswordPost,
  BodyResetResetPasswordAuthResetPasswordPost,
  BodyVerifyRequestTokenAuthRequestVerifyTokenPost,
  BodyVerifyVerifyAuthVerifyPost,
  ErrorModel,
  HTTPValidationError,
  OAuth2AuthorizeResponse,
  OauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetParams,
  OauthGoogleJwtCallbackAuthGoogleCallbackGetParams,
  UserCreate,
  UserRead
} from '../../../model'



/**
 * @summary Auth:Jwt.Login
 */
export const authJwtLoginAuthJwtLoginPost = (
    bodyAuthJwtLoginAuthJwtLoginPost: BodyAuthJwtLoginAuthJwtLoginPost, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BearerResponse>> => {const formUrlEncoded = new URLSearchParams();
if(bodyAuthJwtLoginAuthJwtLoginPost.grant_type !== undefined) {
 formUrlEncoded.append('grant_type', bodyAuthJwtLoginAuthJwtLoginPost.grant_type)
 }
formUrlEncoded.append('username', bodyAuthJwtLoginAuthJwtLoginPost.username)
formUrlEncoded.append('password', bodyAuthJwtLoginAuthJwtLoginPost.password)
if(bodyAuthJwtLoginAuthJwtLoginPost.scope !== undefined) {
 formUrlEncoded.append('scope', bodyAuthJwtLoginAuthJwtLoginPost.scope)
 }
if(bodyAuthJwtLoginAuthJwtLoginPost.client_id !== undefined) {
 formUrlEncoded.append('client_id', bodyAuthJwtLoginAuthJwtLoginPost.client_id)
 }
if(bodyAuthJwtLoginAuthJwtLoginPost.client_secret !== undefined) {
 formUrlEncoded.append('client_secret', bodyAuthJwtLoginAuthJwtLoginPost.client_secret)
 }

    
    return axios.default.post(
      `/auth/jwt/login`,
      formUrlEncoded,options
    );
  }



export const getAuthJwtLoginAuthJwtLoginPostMutationOptions = <TError = AxiosError<ErrorModel | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authJwtLoginAuthJwtLoginPost>>, TError,{data: BodyAuthJwtLoginAuthJwtLoginPost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof authJwtLoginAuthJwtLoginPost>>, TError,{data: BodyAuthJwtLoginAuthJwtLoginPost}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authJwtLoginAuthJwtLoginPost>>, {data: BodyAuthJwtLoginAuthJwtLoginPost}> = (props) => {
          const {data} = props ?? {};

          return  authJwtLoginAuthJwtLoginPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthJwtLoginAuthJwtLoginPostMutationResult = NonNullable<Awaited<ReturnType<typeof authJwtLoginAuthJwtLoginPost>>>
    export type AuthJwtLoginAuthJwtLoginPostMutationBody = BodyAuthJwtLoginAuthJwtLoginPost
    export type AuthJwtLoginAuthJwtLoginPostMutationError = AxiosError<ErrorModel | HTTPValidationError>

    /**
 * @summary Auth:Jwt.Login
 */
export const useAuthJwtLoginAuthJwtLoginPost = <TError = AxiosError<ErrorModel | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authJwtLoginAuthJwtLoginPost>>, TError,{data: BodyAuthJwtLoginAuthJwtLoginPost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof authJwtLoginAuthJwtLoginPost>>,
        TError,
        {data: BodyAuthJwtLoginAuthJwtLoginPost},
        TContext
      > => {

      const mutationOptions = getAuthJwtLoginAuthJwtLoginPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Auth:Jwt.Logout
 */
export const authJwtLogoutAuthJwtLogoutPost = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    return axios.default.post(
      `/auth/jwt/logout`,undefined,options
    );
  }



export const getAuthJwtLogoutAuthJwtLogoutPostMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authJwtLogoutAuthJwtLogoutPost>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof authJwtLogoutAuthJwtLogoutPost>>, TError,void, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authJwtLogoutAuthJwtLogoutPost>>, void> = () => {
          

          return  authJwtLogoutAuthJwtLogoutPost(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthJwtLogoutAuthJwtLogoutPostMutationResult = NonNullable<Awaited<ReturnType<typeof authJwtLogoutAuthJwtLogoutPost>>>
    
    export type AuthJwtLogoutAuthJwtLogoutPostMutationError = AxiosError<void>

    /**
 * @summary Auth:Jwt.Logout
 */
export const useAuthJwtLogoutAuthJwtLogoutPost = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authJwtLogoutAuthJwtLogoutPost>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof authJwtLogoutAuthJwtLogoutPost>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAuthJwtLogoutAuthJwtLogoutPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Register:Register
 */
export const registerRegisterAuthRegisterPost = (
    userCreate: UserCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserRead>> => {
    
    return axios.default.post(
      `/auth/register`,
      userCreate,options
    );
  }



export const getRegisterRegisterAuthRegisterPostMutationOptions = <TError = AxiosError<ErrorModel | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>, TError,{data: UserCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>, TError,{data: UserCreate}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>, {data: UserCreate}> = (props) => {
          const {data} = props ?? {};

          return  registerRegisterAuthRegisterPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterRegisterAuthRegisterPostMutationResult = NonNullable<Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>>
    export type RegisterRegisterAuthRegisterPostMutationBody = UserCreate
    export type RegisterRegisterAuthRegisterPostMutationError = AxiosError<ErrorModel | HTTPValidationError>

    /**
 * @summary Register:Register
 */
export const useRegisterRegisterAuthRegisterPost = <TError = AxiosError<ErrorModel | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>, TError,{data: UserCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>,
        TError,
        {data: UserCreate},
        TContext
      > => {

      const mutationOptions = getRegisterRegisterAuthRegisterPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Reset:Forgot Password
 */
export const resetForgotPasswordAuthForgotPasswordPost = (
    bodyResetForgotPasswordAuthForgotPasswordPost: BodyResetForgotPasswordAuthForgotPasswordPost, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    return axios.default.post(
      `/auth/forgot-password`,
      bodyResetForgotPasswordAuthForgotPasswordPost,options
    );
  }



export const getResetForgotPasswordAuthForgotPasswordPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>, TError,{data: BodyResetForgotPasswordAuthForgotPasswordPost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>, TError,{data: BodyResetForgotPasswordAuthForgotPasswordPost}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>, {data: BodyResetForgotPasswordAuthForgotPasswordPost}> = (props) => {
          const {data} = props ?? {};

          return  resetForgotPasswordAuthForgotPasswordPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResetForgotPasswordAuthForgotPasswordPostMutationResult = NonNullable<Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>>
    export type ResetForgotPasswordAuthForgotPasswordPostMutationBody = BodyResetForgotPasswordAuthForgotPasswordPost
    export type ResetForgotPasswordAuthForgotPasswordPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Reset:Forgot Password
 */
export const useResetForgotPasswordAuthForgotPasswordPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>, TError,{data: BodyResetForgotPasswordAuthForgotPasswordPost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>,
        TError,
        {data: BodyResetForgotPasswordAuthForgotPasswordPost},
        TContext
      > => {

      const mutationOptions = getResetForgotPasswordAuthForgotPasswordPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Reset:Reset Password
 */
export const resetResetPasswordAuthResetPasswordPost = (
    bodyResetResetPasswordAuthResetPasswordPost: BodyResetResetPasswordAuthResetPasswordPost, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    return axios.default.post(
      `/auth/reset-password`,
      bodyResetResetPasswordAuthResetPasswordPost,options
    );
  }



export const getResetResetPasswordAuthResetPasswordPostMutationOptions = <TError = AxiosError<ErrorModel | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>, TError,{data: BodyResetResetPasswordAuthResetPasswordPost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>, TError,{data: BodyResetResetPasswordAuthResetPasswordPost}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>, {data: BodyResetResetPasswordAuthResetPasswordPost}> = (props) => {
          const {data} = props ?? {};

          return  resetResetPasswordAuthResetPasswordPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResetResetPasswordAuthResetPasswordPostMutationResult = NonNullable<Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>>
    export type ResetResetPasswordAuthResetPasswordPostMutationBody = BodyResetResetPasswordAuthResetPasswordPost
    export type ResetResetPasswordAuthResetPasswordPostMutationError = AxiosError<ErrorModel | HTTPValidationError>

    /**
 * @summary Reset:Reset Password
 */
export const useResetResetPasswordAuthResetPasswordPost = <TError = AxiosError<ErrorModel | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>, TError,{data: BodyResetResetPasswordAuthResetPasswordPost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>,
        TError,
        {data: BodyResetResetPasswordAuthResetPasswordPost},
        TContext
      > => {

      const mutationOptions = getResetResetPasswordAuthResetPasswordPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Verify:Request-Token
 */
export const verifyRequestTokenAuthRequestVerifyTokenPost = (
    bodyVerifyRequestTokenAuthRequestVerifyTokenPost: BodyVerifyRequestTokenAuthRequestVerifyTokenPost, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    return axios.default.post(
      `/auth/request-verify-token`,
      bodyVerifyRequestTokenAuthRequestVerifyTokenPost,options
    );
  }



export const getVerifyRequestTokenAuthRequestVerifyTokenPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>, TError,{data: BodyVerifyRequestTokenAuthRequestVerifyTokenPost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>, TError,{data: BodyVerifyRequestTokenAuthRequestVerifyTokenPost}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>, {data: BodyVerifyRequestTokenAuthRequestVerifyTokenPost}> = (props) => {
          const {data} = props ?? {};

          return  verifyRequestTokenAuthRequestVerifyTokenPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyRequestTokenAuthRequestVerifyTokenPostMutationResult = NonNullable<Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>>
    export type VerifyRequestTokenAuthRequestVerifyTokenPostMutationBody = BodyVerifyRequestTokenAuthRequestVerifyTokenPost
    export type VerifyRequestTokenAuthRequestVerifyTokenPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Verify:Request-Token
 */
export const useVerifyRequestTokenAuthRequestVerifyTokenPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>, TError,{data: BodyVerifyRequestTokenAuthRequestVerifyTokenPost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>,
        TError,
        {data: BodyVerifyRequestTokenAuthRequestVerifyTokenPost},
        TContext
      > => {

      const mutationOptions = getVerifyRequestTokenAuthRequestVerifyTokenPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Verify:Verify
 */
export const verifyVerifyAuthVerifyPost = (
    bodyVerifyVerifyAuthVerifyPost: BodyVerifyVerifyAuthVerifyPost, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserRead>> => {
    
    return axios.default.post(
      `/auth/verify`,
      bodyVerifyVerifyAuthVerifyPost,options
    );
  }



export const getVerifyVerifyAuthVerifyPostMutationOptions = <TError = AxiosError<ErrorModel | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>, TError,{data: BodyVerifyVerifyAuthVerifyPost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>, TError,{data: BodyVerifyVerifyAuthVerifyPost}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>, {data: BodyVerifyVerifyAuthVerifyPost}> = (props) => {
          const {data} = props ?? {};

          return  verifyVerifyAuthVerifyPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyVerifyAuthVerifyPostMutationResult = NonNullable<Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>>
    export type VerifyVerifyAuthVerifyPostMutationBody = BodyVerifyVerifyAuthVerifyPost
    export type VerifyVerifyAuthVerifyPostMutationError = AxiosError<ErrorModel | HTTPValidationError>

    /**
 * @summary Verify:Verify
 */
export const useVerifyVerifyAuthVerifyPost = <TError = AxiosError<ErrorModel | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>, TError,{data: BodyVerifyVerifyAuthVerifyPost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>,
        TError,
        {data: BodyVerifyVerifyAuthVerifyPost},
        TContext
      > => {

      const mutationOptions = getVerifyVerifyAuthVerifyPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Oauth:Google.Jwt.Authorize
 */
export const oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet = (
    params?: OauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<OAuth2AuthorizeResponse>> => {
    
    return axios.default.get(
      `/auth/google/authorize`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getOauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetQueryKey = (params?: OauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetParams,) => {
    return [`/auth/google/authorize`, ...(params ? [params]: [])] as const;
    }

    
export const getOauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetQueryOptions = <TData = Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError = AxiosError<HTTPValidationError>>(params?: OauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>> = ({ signal }) => oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError, TData> & { queryKey: QueryKey }
}

export type OauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetQueryResult = NonNullable<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>>
export type OauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetQueryError = AxiosError<HTTPValidationError>


export function useOauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError = AxiosError<HTTPValidationError>>(
 params: undefined |  OauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useOauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: OauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useOauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: OauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
/**
 * @summary Oauth:Google.Jwt.Authorize
 */

export function useOauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: OauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getOauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * The response varies based on the authentication backend used.
 * @summary Oauth:Google.Jwt.Callback
 */
export const oauthGoogleJwtCallbackAuthGoogleCallbackGet = (
    params?: OauthGoogleJwtCallbackAuthGoogleCallbackGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    return axios.default.get(
      `/auth/google/callback`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getOauthGoogleJwtCallbackAuthGoogleCallbackGetQueryKey = (params?: OauthGoogleJwtCallbackAuthGoogleCallbackGetParams,) => {
    return [`/auth/google/callback`, ...(params ? [params]: [])] as const;
    }

    
export const getOauthGoogleJwtCallbackAuthGoogleCallbackGetQueryOptions = <TData = Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError = AxiosError<ErrorModel | HTTPValidationError>>(params?: OauthGoogleJwtCallbackAuthGoogleCallbackGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOauthGoogleJwtCallbackAuthGoogleCallbackGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>> = ({ signal }) => oauthGoogleJwtCallbackAuthGoogleCallbackGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError, TData> & { queryKey: QueryKey }
}

export type OauthGoogleJwtCallbackAuthGoogleCallbackGetQueryResult = NonNullable<Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>>
export type OauthGoogleJwtCallbackAuthGoogleCallbackGetQueryError = AxiosError<ErrorModel | HTTPValidationError>


export function useOauthGoogleJwtCallbackAuthGoogleCallbackGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError = AxiosError<ErrorModel | HTTPValidationError>>(
 params: undefined |  OauthGoogleJwtCallbackAuthGoogleCallbackGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useOauthGoogleJwtCallbackAuthGoogleCallbackGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError = AxiosError<ErrorModel | HTTPValidationError>>(
 params?: OauthGoogleJwtCallbackAuthGoogleCallbackGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useOauthGoogleJwtCallbackAuthGoogleCallbackGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError = AxiosError<ErrorModel | HTTPValidationError>>(
 params?: OauthGoogleJwtCallbackAuthGoogleCallbackGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
/**
 * @summary Oauth:Google.Jwt.Callback
 */

export function useOauthGoogleJwtCallbackAuthGoogleCallbackGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError = AxiosError<ErrorModel | HTTPValidationError>>(
 params?: OauthGoogleJwtCallbackAuthGoogleCallbackGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getOauthGoogleJwtCallbackAuthGoogleCallbackGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



