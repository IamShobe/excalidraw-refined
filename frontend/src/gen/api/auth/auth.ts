/**
 * Generated by orval v7.0.1 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import type {
  BearerResponse,
  BodyAuthJwtLoginAuthJwtLoginPost,
  BodyResetForgotPasswordAuthForgotPasswordPost,
  BodyResetResetPasswordAuthResetPasswordPost,
  BodyVerifyRequestTokenAuthRequestVerifyTokenPost,
  BodyVerifyVerifyAuthVerifyPost,
  ErrorModel,
  HTTPValidationError,
  OAuth2AuthorizeResponse,
  OauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetParams,
  OauthGoogleJwtCallbackAuthGoogleCallbackGetParams,
  UserCreate,
  UserRead
} from '../../model'
import { customInstance } from '../../../api/axios';


type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];


/**
 * @summary Auth:Jwt.Login
 */
export const authJwtLoginAuthJwtLoginPost = (
    bodyAuthJwtLoginAuthJwtLoginPost: BodyAuthJwtLoginAuthJwtLoginPost,
 options?: SecondParameter<typeof customInstance>,) => {
      
      const formUrlEncoded = new URLSearchParams();
if(bodyAuthJwtLoginAuthJwtLoginPost.grant_type !== undefined) {
 formUrlEncoded.append('grant_type', bodyAuthJwtLoginAuthJwtLoginPost.grant_type)
 }
formUrlEncoded.append('username', bodyAuthJwtLoginAuthJwtLoginPost.username)
formUrlEncoded.append('password', bodyAuthJwtLoginAuthJwtLoginPost.password)
if(bodyAuthJwtLoginAuthJwtLoginPost.scope !== undefined) {
 formUrlEncoded.append('scope', bodyAuthJwtLoginAuthJwtLoginPost.scope)
 }
if(bodyAuthJwtLoginAuthJwtLoginPost.client_id !== undefined) {
 formUrlEncoded.append('client_id', bodyAuthJwtLoginAuthJwtLoginPost.client_id)
 }
if(bodyAuthJwtLoginAuthJwtLoginPost.client_secret !== undefined) {
 formUrlEncoded.append('client_secret', bodyAuthJwtLoginAuthJwtLoginPost.client_secret)
 }

      return customInstance<BearerResponse>(
      {url: `/auth/jwt/login`, method: 'POST',
      headers: {'Content-Type': 'application/x-www-form-urlencoded', },
       data: formUrlEncoded
    },
      options);
    }
  


export const getAuthJwtLoginAuthJwtLoginPostMutationOptions = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authJwtLoginAuthJwtLoginPost>>, TError,{data: BodyAuthJwtLoginAuthJwtLoginPost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authJwtLoginAuthJwtLoginPost>>, TError,{data: BodyAuthJwtLoginAuthJwtLoginPost}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authJwtLoginAuthJwtLoginPost>>, {data: BodyAuthJwtLoginAuthJwtLoginPost}> = (props) => {
          const {data} = props ?? {};

          return  authJwtLoginAuthJwtLoginPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthJwtLoginAuthJwtLoginPostMutationResult = NonNullable<Awaited<ReturnType<typeof authJwtLoginAuthJwtLoginPost>>>
    export type AuthJwtLoginAuthJwtLoginPostMutationBody = BodyAuthJwtLoginAuthJwtLoginPost
    export type AuthJwtLoginAuthJwtLoginPostMutationError = ErrorModel | HTTPValidationError

    /**
 * @summary Auth:Jwt.Login
 */
export const useAuthJwtLoginAuthJwtLoginPost = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authJwtLoginAuthJwtLoginPost>>, TError,{data: BodyAuthJwtLoginAuthJwtLoginPost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof authJwtLoginAuthJwtLoginPost>>,
        TError,
        {data: BodyAuthJwtLoginAuthJwtLoginPost},
        TContext
      > => {

      const mutationOptions = getAuthJwtLoginAuthJwtLoginPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Auth:Jwt.Logout
 */
export const authJwtLogoutAuthJwtLogoutPost = (
    
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<unknown>(
      {url: `/auth/jwt/logout`, method: 'POST'
    },
      options);
    }
  


export const getAuthJwtLogoutAuthJwtLogoutPostMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authJwtLogoutAuthJwtLogoutPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authJwtLogoutAuthJwtLogoutPost>>, TError,void, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authJwtLogoutAuthJwtLogoutPost>>, void> = () => {
          

          return  authJwtLogoutAuthJwtLogoutPost(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthJwtLogoutAuthJwtLogoutPostMutationResult = NonNullable<Awaited<ReturnType<typeof authJwtLogoutAuthJwtLogoutPost>>>
    
    export type AuthJwtLogoutAuthJwtLogoutPostMutationError = void

    /**
 * @summary Auth:Jwt.Logout
 */
export const useAuthJwtLogoutAuthJwtLogoutPost = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authJwtLogoutAuthJwtLogoutPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof authJwtLogoutAuthJwtLogoutPost>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAuthJwtLogoutAuthJwtLogoutPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Register:Register
 */
export const registerRegisterAuthRegisterPost = (
    userCreate: UserCreate,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UserRead>(
      {url: `/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreate
    },
      options);
    }
  


export const getRegisterRegisterAuthRegisterPostMutationOptions = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>, TError,{data: UserCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>, TError,{data: UserCreate}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>, {data: UserCreate}> = (props) => {
          const {data} = props ?? {};

          return  registerRegisterAuthRegisterPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterRegisterAuthRegisterPostMutationResult = NonNullable<Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>>
    export type RegisterRegisterAuthRegisterPostMutationBody = UserCreate
    export type RegisterRegisterAuthRegisterPostMutationError = ErrorModel | HTTPValidationError

    /**
 * @summary Register:Register
 */
export const useRegisterRegisterAuthRegisterPost = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>, TError,{data: UserCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>,
        TError,
        {data: UserCreate},
        TContext
      > => {

      const mutationOptions = getRegisterRegisterAuthRegisterPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Reset:Forgot Password
 */
export const resetForgotPasswordAuthForgotPasswordPost = (
    bodyResetForgotPasswordAuthForgotPasswordPost: BodyResetForgotPasswordAuthForgotPasswordPost,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<unknown>(
      {url: `/auth/forgot-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bodyResetForgotPasswordAuthForgotPasswordPost
    },
      options);
    }
  


export const getResetForgotPasswordAuthForgotPasswordPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>, TError,{data: BodyResetForgotPasswordAuthForgotPasswordPost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>, TError,{data: BodyResetForgotPasswordAuthForgotPasswordPost}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>, {data: BodyResetForgotPasswordAuthForgotPasswordPost}> = (props) => {
          const {data} = props ?? {};

          return  resetForgotPasswordAuthForgotPasswordPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResetForgotPasswordAuthForgotPasswordPostMutationResult = NonNullable<Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>>
    export type ResetForgotPasswordAuthForgotPasswordPostMutationBody = BodyResetForgotPasswordAuthForgotPasswordPost
    export type ResetForgotPasswordAuthForgotPasswordPostMutationError = HTTPValidationError

    /**
 * @summary Reset:Forgot Password
 */
export const useResetForgotPasswordAuthForgotPasswordPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>, TError,{data: BodyResetForgotPasswordAuthForgotPasswordPost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>,
        TError,
        {data: BodyResetForgotPasswordAuthForgotPasswordPost},
        TContext
      > => {

      const mutationOptions = getResetForgotPasswordAuthForgotPasswordPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Reset:Reset Password
 */
export const resetResetPasswordAuthResetPasswordPost = (
    bodyResetResetPasswordAuthResetPasswordPost: BodyResetResetPasswordAuthResetPasswordPost,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<unknown>(
      {url: `/auth/reset-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bodyResetResetPasswordAuthResetPasswordPost
    },
      options);
    }
  


export const getResetResetPasswordAuthResetPasswordPostMutationOptions = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>, TError,{data: BodyResetResetPasswordAuthResetPasswordPost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>, TError,{data: BodyResetResetPasswordAuthResetPasswordPost}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>, {data: BodyResetResetPasswordAuthResetPasswordPost}> = (props) => {
          const {data} = props ?? {};

          return  resetResetPasswordAuthResetPasswordPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResetResetPasswordAuthResetPasswordPostMutationResult = NonNullable<Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>>
    export type ResetResetPasswordAuthResetPasswordPostMutationBody = BodyResetResetPasswordAuthResetPasswordPost
    export type ResetResetPasswordAuthResetPasswordPostMutationError = ErrorModel | HTTPValidationError

    /**
 * @summary Reset:Reset Password
 */
export const useResetResetPasswordAuthResetPasswordPost = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>, TError,{data: BodyResetResetPasswordAuthResetPasswordPost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>,
        TError,
        {data: BodyResetResetPasswordAuthResetPasswordPost},
        TContext
      > => {

      const mutationOptions = getResetResetPasswordAuthResetPasswordPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Verify:Request-Token
 */
export const verifyRequestTokenAuthRequestVerifyTokenPost = (
    bodyVerifyRequestTokenAuthRequestVerifyTokenPost: BodyVerifyRequestTokenAuthRequestVerifyTokenPost,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<unknown>(
      {url: `/auth/request-verify-token`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bodyVerifyRequestTokenAuthRequestVerifyTokenPost
    },
      options);
    }
  


export const getVerifyRequestTokenAuthRequestVerifyTokenPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>, TError,{data: BodyVerifyRequestTokenAuthRequestVerifyTokenPost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>, TError,{data: BodyVerifyRequestTokenAuthRequestVerifyTokenPost}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>, {data: BodyVerifyRequestTokenAuthRequestVerifyTokenPost}> = (props) => {
          const {data} = props ?? {};

          return  verifyRequestTokenAuthRequestVerifyTokenPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyRequestTokenAuthRequestVerifyTokenPostMutationResult = NonNullable<Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>>
    export type VerifyRequestTokenAuthRequestVerifyTokenPostMutationBody = BodyVerifyRequestTokenAuthRequestVerifyTokenPost
    export type VerifyRequestTokenAuthRequestVerifyTokenPostMutationError = HTTPValidationError

    /**
 * @summary Verify:Request-Token
 */
export const useVerifyRequestTokenAuthRequestVerifyTokenPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>, TError,{data: BodyVerifyRequestTokenAuthRequestVerifyTokenPost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>,
        TError,
        {data: BodyVerifyRequestTokenAuthRequestVerifyTokenPost},
        TContext
      > => {

      const mutationOptions = getVerifyRequestTokenAuthRequestVerifyTokenPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Verify:Verify
 */
export const verifyVerifyAuthVerifyPost = (
    bodyVerifyVerifyAuthVerifyPost: BodyVerifyVerifyAuthVerifyPost,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UserRead>(
      {url: `/auth/verify`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bodyVerifyVerifyAuthVerifyPost
    },
      options);
    }
  


export const getVerifyVerifyAuthVerifyPostMutationOptions = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>, TError,{data: BodyVerifyVerifyAuthVerifyPost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>, TError,{data: BodyVerifyVerifyAuthVerifyPost}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>, {data: BodyVerifyVerifyAuthVerifyPost}> = (props) => {
          const {data} = props ?? {};

          return  verifyVerifyAuthVerifyPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyVerifyAuthVerifyPostMutationResult = NonNullable<Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>>
    export type VerifyVerifyAuthVerifyPostMutationBody = BodyVerifyVerifyAuthVerifyPost
    export type VerifyVerifyAuthVerifyPostMutationError = ErrorModel | HTTPValidationError

    /**
 * @summary Verify:Verify
 */
export const useVerifyVerifyAuthVerifyPost = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>, TError,{data: BodyVerifyVerifyAuthVerifyPost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>,
        TError,
        {data: BodyVerifyVerifyAuthVerifyPost},
        TContext
      > => {

      const mutationOptions = getVerifyVerifyAuthVerifyPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Oauth:Google.Jwt.Authorize
 */
export const oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet = (
    params?: OauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<OAuth2AuthorizeResponse>(
      {url: `/auth/google/authorize`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getOauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetQueryKey = (params?: OauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetParams,) => {
    return [`/auth/google/authorize`, ...(params ? [params]: [])] as const;
    }

    
export const getOauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetQueryOptions = <TData = Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError = HTTPValidationError>(params?: OauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>> = ({ signal }) => oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError, TData> & { queryKey: QueryKey }
}

export type OauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetQueryResult = NonNullable<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>>
export type OauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetQueryError = HTTPValidationError


export function useOauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError = HTTPValidationError>(
 params: undefined |  OauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useOauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError = HTTPValidationError>(
 params?: OauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useOauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError = HTTPValidationError>(
 params?: OauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
/**
 * @summary Oauth:Google.Jwt.Authorize
 */

export function useOauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError = HTTPValidationError>(
 params?: OauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeAuthGoogleAuthorizeGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getOauthGoogleJwtAuthorizeAuthGoogleAuthorizeGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * The response varies based on the authentication backend used.
 * @summary Oauth:Google.Jwt.Callback
 */
export const oauthGoogleJwtCallbackAuthGoogleCallbackGet = (
    params?: OauthGoogleJwtCallbackAuthGoogleCallbackGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/auth/google/callback`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getOauthGoogleJwtCallbackAuthGoogleCallbackGetQueryKey = (params?: OauthGoogleJwtCallbackAuthGoogleCallbackGetParams,) => {
    return [`/auth/google/callback`, ...(params ? [params]: [])] as const;
    }

    
export const getOauthGoogleJwtCallbackAuthGoogleCallbackGetQueryOptions = <TData = Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError = ErrorModel | HTTPValidationError>(params?: OauthGoogleJwtCallbackAuthGoogleCallbackGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOauthGoogleJwtCallbackAuthGoogleCallbackGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>> = ({ signal }) => oauthGoogleJwtCallbackAuthGoogleCallbackGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError, TData> & { queryKey: QueryKey }
}

export type OauthGoogleJwtCallbackAuthGoogleCallbackGetQueryResult = NonNullable<Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>>
export type OauthGoogleJwtCallbackAuthGoogleCallbackGetQueryError = ErrorModel | HTTPValidationError


export function useOauthGoogleJwtCallbackAuthGoogleCallbackGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError = ErrorModel | HTTPValidationError>(
 params: undefined |  OauthGoogleJwtCallbackAuthGoogleCallbackGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useOauthGoogleJwtCallbackAuthGoogleCallbackGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError = ErrorModel | HTTPValidationError>(
 params?: OauthGoogleJwtCallbackAuthGoogleCallbackGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useOauthGoogleJwtCallbackAuthGoogleCallbackGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError = ErrorModel | HTTPValidationError>(
 params?: OauthGoogleJwtCallbackAuthGoogleCallbackGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
/**
 * @summary Oauth:Google.Jwt.Callback
 */

export function useOauthGoogleJwtCallbackAuthGoogleCallbackGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError = ErrorModel | HTTPValidationError>(
 params?: OauthGoogleJwtCallbackAuthGoogleCallbackGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtCallbackAuthGoogleCallbackGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getOauthGoogleJwtCallbackAuthGoogleCallbackGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



